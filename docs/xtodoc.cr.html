<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>xtodoc.cr</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">xtodoc.cr</h1>
</header>
<pre><code>require &quot;file_utils&quot;
def makeindex(output, dir)
  files = Dir[&quot;#{dir}/**&quot;]
  output.puts
  files.each do |file|
    if !File.directory?(file)
      output.puts(&quot;./[#{File.basename(file, File.extname(file))}](./#{File.basename(file, File.extname(file))}.html)&quot;)
    else
      output.puts(&quot;./[#{File.basename(file, File.extname(file))}](./#{File.basename(file, File.extname(file))}/index.html)&quot;)
    end
    output.puts
  end
end

def image?(file)
  file.to_s.includes?(&quot;.gif&quot;) || file.to_s.includes?(&quot;.png&quot;) || file.to_s.includes?(&quot;.jpg&quot;)
end

def begin_file(file, output_file)
  output_file.puts(&quot;---&quot;)
  output_file.puts(&quot;title: #{File.basename(file)}&quot;)
  output_file.puts(&quot;---&quot;)
end

def nix(file, output_file, file_extension)
  begin_file(file, output_file)
  code = true
  input_file = File.open(file)
  file_lines = input_file.read_line
  if file_lines.chomp != &quot;/*&quot;
    output_file.puts(&quot;```#{file_extension}&quot;)
  end
  input_file.each_line do |line|
    if line.chomp.lstrip.starts_with? &quot;/*&quot;
      code = false
      output_file.puts(&quot;```&quot;)
    elsif line.chomp.lstrip.starts_with? &quot;*/&quot;
      code = true
      output_file.puts(&quot;```#{file_extension}&quot;)
    else
      if code == true
        output_file.puts(line)
      else
        output_file.puts(line.lstrip)
      end
    end
  end
  output_file.puts(&quot;```&quot;)
  output_file.close
end

def md(file, output_file)
  begin_file(file, output_file)
  File.open(file).each_line do |line|
    output_file.puts(line)
  end
  output_file.close
end

def other(file, output_file)
  begin_file(file, output_file)
  output_file.puts(&quot;```&quot;)
  File.open(file).each_line do |line|
    output_file.puts(line)
  end
  output_file.puts(&quot;```&quot;)
  output_file.close
end

def mdfile(file, output_dir)
  case File.extname(file).delete(&quot;.&quot;)
  when &quot;nix&quot;
    nix(file, File.new(&quot;#{output_dir}/#{file}.md&quot;, &quot;w&quot;), &quot;nix&quot;)
  when &quot;md&quot;
    md(file, File.new(&quot;#{output_dir}/#{file}&quot;, &quot;w&quot;))
  else
    other(file, File.new(&quot;#{output_dir}/#{file}.md&quot;, &quot;w&quot;))
  end
end

# config = TOML::Parser.new(File.open(&quot;./xtodoc.toml&quot;).read).parsed
OUTPUT_DIR = &quot;docs/&quot;
# FileUtils.rm_r(OUTPUT_DIR)
`rm -rf #{OUTPUT_DIR}`
resource_paths = Dir.glob(&quot;**/*&quot;).reject do |path|
  File.directory?(path) || path.ends_with?(&quot;index.md&quot;) || image?(path)
end
images = Dir.glob(&quot;**/*&quot;).select do |path|
  image?(path)
end
directories = Dir.glob(&quot;**/*&quot;).select do |path|
  File.directory?(path) &amp; (path != OUTPUT_DIR)
end
#Dir.mkdir OUTPUT_DIR
`mkdir #{OUTPUT_DIR}`
directories.each do |dir|
  #Dir.mkdir &quot;#{OUTPUT_DIR}/#{dir}&quot;
  mkcommand = &quot;mkdir #{OUTPUT_DIR}/#{dir}&quot;
  `#{mkcommand}`
end
resource_paths.each do |file|
  #spawn do
    mdfile(file, OUTPUT_DIR)
  #end
end
#Fiber.yield
directories.each do |dir|
  index = File.new(&quot;#{OUTPUT_DIR}/#{dir}/index.md&quot;, &quot;w&quot;)
  begin_file(dir, index)
  if File.exists?(&quot;#{dir}/index.md&quot;)
    File.open(&quot;#{dir}/index.md&quot;).each_line do |output|
      index.puts(output)
    end
  end
  makeindex(index, &quot;#{OUTPUT_DIR}#{dir}&quot;)
  index.close
end
index = File.open(&quot;#{OUTPUT_DIR}/index.md&quot;, &quot;w&quot;)
begin_file(OUTPUT_DIR.to_s, index)
File.open(&quot;./index.md&quot;).each_line do |output|
  index.puts(output)
end
makeindex(index, OUTPUT_DIR.to_s)
images.each do |image|
  FileUtils.cp(image, &quot;./docs/#{image}&quot;)
end
index.close
resource_paths_html = Dir[&quot;./docs/**/*&quot;].reject do |path|
  File.directory?(path) || image?(path)
end
index.close
channel = Channel(Nil).new
#channel2 = Channel(Nil).new
num_needed = resource_paths_html.size
threaded = false
if threaded == true
resource_paths_html.each do |file|
  spawn do
    system &quot;./addons/pandoc/pandoc.sh #{file} #{file[0..-4]}.html&quot;
    #`./addons/pandoc/pandoc.sh #{file} #{file[0..-4]}`
    File.delete file
    #`rm #{file}`
    channel.send(nil)
  end
end
#spawn do
  (1..num_needed).each { channel.receive }
#  channel2.send(nil)
#end
#channel2.receive
else

resource_paths_html.each do |file|
    system &quot;./addons/pandoc/pandoc.sh #{file} #{file[0..-4]}.html&quot;
    #`./addons/pandoc/pandoc.sh #{file} #{file[0..-4]}`
    File.delete file
    #`rm #{file}`
end
end</code></pre>
</body>
</html>
